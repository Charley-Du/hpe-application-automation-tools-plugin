/*
 *  Certain versions of software accessible here may contain branding from
 *  Hewlett-Packard Company (now HP Inc.) and Hewlett Packard Enterprise Company.
 *  This software was acquired by Micro Focus on September 1, 2017, and is now
 *  offered by OpenText.
 *  Any reference to the HP and Hewlett Packard Enterprise/HPE marks is historical
 *  in nature, and the HP and Hewlett Packard Enterprise/HPE marks are the
 *  property of their respective owners.
 *  OpenText is a trademark of Open Text.
 *  __________________________________________________________________
 *  MIT License
 *
 *  Copyright 2012-2025 Open Text.
 *
 *  The only warranties for products and services of Open Text and
 *  its affiliates and licensors ("Open Text") are as may be set forth
 *  in the express warranty statements accompanying such products and services.
 *  Nothing herein should be construed as constituting an additional warranty.
 *  Open Text shall not be liable for technical or editorial errors or
 *  omissions contained herein. The information contained herein is subject
 *  to change without notice.
 *
 *  Except as specifically indicated otherwise, this document contains
 *  confidential information and a valid license is required for possession,
 *  use or copying. If this work is provided to the U.S. Government,
 *  consistent with FAR 12.211 and 12.212, Commercial Computer Software,
 *  Computer Software Documentation, and Technical Data for Commercial Items are
 *  licensed to the U.S. Government under vendor's standard commercial license.
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  ___________________________________________________________________
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(["chartist"], function (Chartist) {
            return (root.returnExportsGlobal = factory(Chartist));
        });
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory(require("chartist"));
    } else {
        root['Chartist.plugins.tooltips'] = factory(Chartist);
    }
}(this, function (Chartist) {

    /**
     * Chartist.js plugin to display a data label on top of the points in a line chart.
     *
     */
    /* global Chartist */
    (function (window, document, Chartist) {
        'use strict';

        var defaultOptions = {
            currency: undefined,
            currencyFormatCallback: undefined,
            tooltipOffset: {
                x: 0,
                y: 10
            },
            anchorToPoint: false,
            appendToBody: false,
            class: undefined,
            pointClass: 'ct-point'
        };

        Chartist.plugins = Chartist.plugins || {};
        Chartist.plugins.tooltip = function (options) {
            options = Chartist.extend({}, defaultOptions, options);

            return function tooltip(chart) {
                var tooltipSelector = options.pointClass;
                if (chart instanceof Chartist.Bar) {
                    tooltipSelector = 'ct-bar';
                } else if (chart instanceof Chartist.Pie) {
                    // Added support for donut graph
                    if (chart.options.donut) {
                        tooltipSelector = 'ct-slice-donut';
                    } else {
                        tooltipSelector = 'ct-slice-pie';
                    }
                }

                var $chart = chart.container;
                var $toolTip = $chart.querySelector('.chartist-tooltip');
                if (!$toolTip) {
                    $toolTip = document.createElement('div');
                    $toolTip.className = (!options.class) ? 'chartist-tooltip' : 'chartist-tooltip ' + options.class;
                    if (!options.appendToBody) {
                        $chart.appendChild($toolTip);
                    } else {
                        document.body.appendChild($toolTip);
                    }
                }
                var height = $toolTip.offsetHeight;
                var width = $toolTip.offsetWidth;

                hide($toolTip);

                function on(event, selector, callback) {
                    $chart.addEventListener(event, function (e) {
                        if (!selector || hasClass(e.target, selector))
                            callback(e);
                    });
                }

                on('mouseover', tooltipSelector, function (event) {
                    var $point = event.target;
                    var tooltipText = '';

                    var isPieChart = (chart instanceof Chartist.Pie) ? $point : $point.parentNode;
                    var seriesName = (isPieChart) ? $point.parentNode.getAttribute('ct:meta') || $point.parentNode.getAttribute('ct:series-name') : '';
                    var meta = $point.getAttribute('ct:meta') || seriesName || '';
                    var hasMeta = !!meta;
                    var value = $point.getAttribute('ct:value');

                    if (options.transformTooltipTextFnc && typeof options.transformTooltipTextFnc === 'function') {
                        value = options.transformTooltipTextFnc(value);
                    }

                    if (options.tooltipFnc && typeof options.tooltipFnc === 'function') {
                        tooltipText = options.tooltipFnc(meta, value);
                    } else {
                        if (options.metaIsHTML) {
                            var txt = document.createElement('textarea');
                            txt.innerHTML = meta;
                            meta = txt.value;
                        }

                        meta = '<span class="chartist-tooltip-meta">' + meta + '</span>';

                        if (hasMeta) {
                            tooltipText += meta + '<br>';
                        } else {
                            // For Pie Charts also take the labels into account
                            // Could add support for more charts here as well!
                            if (chart instanceof Chartist.Pie) {
                                var label = next($point, 'ct-label');
                                if (label) {
                                    tooltipText += text(label) + '<br>';
                                }
                            }
                        }

                        if (value) {
                            if (options.currency) {
                                if (options.currencyFormatCallback != undefined) {
                                    value = options.currencyFormatCallback(value, options);
                                } else {
                                    value = options.currency + value.replace(/(\d)(?=(\d{3})+(?:\.\d+)?$)/g, '$1,');
                                }
                            }
                            value = '<span class="chartist-tooltip-value">' + value + '</span>';
                            tooltipText += value;
                        }
                    }

                    if(tooltipText) {
                        $toolTip.innerHTML = tooltipText;
                        setPosition(event);
                        show($toolTip);

                        // Remember height and width to avoid wrong position in IE
                        height = $toolTip.offsetHeight;
                        width = $toolTip.offsetWidth;
                    }
                });

                on('mouseout', tooltipSelector, function () {
                    hide($toolTip);
                });

                on('mousemove', null, function (event) {
                    if (false === options.anchorToPoint)
                        setPosition(event);
                });

                function setPosition(event) {
                    height = height || $toolTip.offsetHeight;
                    width = width || $toolTip.offsetWidth;
                    var offsetX = - width / 2 + options.tooltipOffset.x
                    var offsetY = - height + options.tooltipOffset.y;
                    var anchorX, anchorY;

                    if (!options.appendToBody) {
                        var box = $chart.getBoundingClientRect();
                        var left = event.pageX - box.left - window.pageXOffset ;
                        var top = event.pageY - box.top - window.pageYOffset ;

                        if (true === options.anchorToPoint && event.target.x2 && event.target.y2) {
                            anchorX = parseInt(event.target.x2.baseVal.value);
                            anchorY = parseInt(event.target.y2.baseVal.value);
                        }

                        $toolTip.style.top = (anchorY || top) + offsetY + 'px';
                        $toolTip.style.left = (anchorX || left) + offsetX + 'px';
                    } else {
                        $toolTip.style.top = event.pageY + offsetY + 'px';
                        $toolTip.style.left = event.pageX + offsetX + 'px';
                    }
                }
            }
        };

        function show(element) {
            if(!hasClass(element, 'tooltip-show')) {
                element.className = element.className + ' tooltip-show';
            }
        }

        function hide(element) {
            var regex = new RegExp('tooltip-show' + '\\s*', 'gi');
            element.className = element.className.replace(regex, '').trim();
        }

        function hasClass(element, className) {
            return (' ' + element.getAttribute('class') + ' ').indexOf(' ' + className + ' ') > -1;
        }

        function next(element, className) {
            do {
                element = element.nextSibling;
            } while (element && !hasClass(element, className));
            return element;
        }

        function text(element) {
            return element.innerText || element.textContent;
        }

    } (window, document, Chartist));

    return Chartist.plugins.tooltips;

}));
